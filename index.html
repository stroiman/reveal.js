<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="css/theme/simple.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!-- Mermaid -->
    <link rel="stylesheet" href="node_modules/mermaid/dist/mermaid.css">
    <script src="node_modules/mermaid/dist/mermaid.js"></script>
    <style>
.reveal .diagram-display {
  padding: 0;
  margin: 0;
  min-height: 700px;
  min-width:100%;
  height:auto;
}
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section><h1>State Management in React</h1></section>

        <section>
          <section>
            <h2> Single Source of Truth </h2>
            <ul>
              <li class="fragment">One single source for any independent data</li>
              <li class="fragment">Input elements use controlled components</li>
              <li class="fragment">If more components need access, we <em>lift the state up</em>
                <ul>
                  <li class="fragment">Components receives the value as props</li>
                  <li class="fragment">Components can <em>request</em> updates using events</li>
                </ul>
              </li>
            </ul>
          </section>
          <section class="diagram-slide">
            <h2>Controlled component</h2>
            <pre><code data-trim data-noescape class="javascript">const MarkdownEditField = () =&gt; {
  const [ value, setValue ] = useState("Initial value");
  const onChange = (e) =&gt; { setValue(e.target.value); };

  return (
    &lt;textarea value={value} onChange={onChange} /&gt;
  );
}
            </code></pre>
          </section>
          <section class="diagram-slide">
            <h2>State lifted up</h2>
            <pre><code data-trim data-noescape class="javascript">const MarkdownEditField = ({value, onValueChange}: MarkdownFieldProps) =&gt; {
  const onChange = (e) =&gt; { onValueChange(e.target.value); };
  return (
    &lt;textarea value={state} onChange={onChange} /&gt;
  );
}

const MarkdownWithPreview = () =&gt; {
  const [ value, setValue ] = useState("");
  return (
    &lt;MarkdownEditField value={value} onValueChange={setValue} &gt;
    &lt;MarkdownPreview value={value} &gt;
  )
}
            </code></pre>
          </section>
        </section>
        <section>
          <h2>Redux</h2>
          <p>
          Helps lifting state up. Useful scenarios:
          </p>
          <ul>
            <li>Interaction between many components</li>
            <li>Complex state management
              <ul>
                <li>Asynchronous code</li>
                <li>WebSocket push</li>
              </ul>
            </li>
          </ul>
          <p>
          <small>Not all parts needs to be maintained by redux</small>
          </p>
        </section>
        <section>
          <section>
            <h2>Redux components</h2>
            <ul>
              <li class="fragment">Primary<ul>
                  <li>Store</li>
                  <li>Actions</li>
                  <li>Reducers</li>
                </ul>
              </li>
              <li class="fragment">Secondary (but just as important)
                <ul>
                  <li>Action Creators</li>
                  <li>Selectors</li>
                </ul>
              </li>
          </section>
          <section>
            <h2>Actions</h2>
            Immutable piece of data representing a desired change.
            <pre><code data-trim data-noescape class="javascript">
              {
                // Type is the only required property
                type: "SET_FINE_TUNING_GAIN",
                payload: { // Wrapping data in payload is a _recommendation_
                  earSide: "left",
                  channelNo: 3,
                  fineTuning: "+4dB"
                }
              }
            </code></pre>
          </section>
          <section>
            <h2>Reducers</h2>
            Calculates how an action affects the state tree
            <pre><code data-trim data-noescape class="javascript">
              const reduce = (state = initialState, action) => {
                switch(action.type) {
                  case "SET_FINE_TUNING_GAIN":
                    const { channelNo, earSide, fineTuning } = action;
                    // Copy the array to keep data immutable
                    const channelsCopy = state[earSide].slice();
                    channelsCopy[action.channel] = { ...channelsCopy[action.channel], fineTuningGain }

                    // Return a copy of the initial state, with the modifications applied
                    return { ...state, [earSide]: channelsCopy }
                  case "RESET_FINE_TUNING": ...
                  default:
                    // A different action was dispatched, return unmodified state
                    return state;
                }
              }
            </code></pre>
            <small class="fragment">Helper libraries exist to simplify this</small>
          </section>
          <section>
            <h2>Composing Reducers</h2>
            <pre><code data-trim data-noescape class="javascript">
              const fooReducer = (state = { bazFoo: null }, action) => state;
              const barReducer = (state = { bazBar: null }, action) => state;

              const rootReduxer = combineReducers({
                foo: fooReducer,
                bar: barReducer
              })

              // State tree will look like this
              { foo: { // This bit maintained by foo reducer
                  bazFoo: null
                },
                bar: { // This bit maintained by bar reducer
                  bazBar: null
              } }
            </code></pre>
          </section>
          <section>
            <h2>Store</h2>
            <pre><code data-trim data-noescape class="javascript">
              const store = createStore(rootReducer)

              // Dispatch actions
              store.dispatch({ type: "RESET_FINE_TUNINGS" });
              // This will emit events when the state changes

              // Read the state
              store.getState();
            </code></pre>
          </section>
          <section>
            <h2>Action Creators</h2>
            Functions that return actions
            <pre><code data-trim data-noescape class="javascript">
              const resetFineTunings = () => {
                return {
                  type: "RESET_FINE_TUNINGS"
                }
              }

              const setFineTuningGains = (side: "left"|"right",
                  channelNo: number, fineTuning: string) => {
                return {
                  type: "SET_FINE_TUNING_GAIN",
                  payload: { earSide, channelNo, fineTuning }
                }
              }
            </code></pre>
          </section>
          <section>
            <h2>Selectors</h2>
            Functions that retrieve bits of state
            <pre><code data-trim data-noescape class="javascript">
              const getFineTuningGain = (state: RootState) =>
                state.hearingProfileFitting.fineTuning;
            </code></pre>
            <small>
              Selectors are not necessary, but makes the state tree easier to
              refactor.
            </small>
          </section>
        </section>
        <section>
          <section>
            <h1>React Redux Bindings</h1>
          </section>
          <section>
            <h4>Create a <code>Provider</code></h4>

            <pre><code data-trim data-noescape class="react">
                // App.tsx or Root.tsx, or some parent component
                import { createStore } from 'redux'
                import { Provider } from 'react-redux';

                const store = createStore(rootReducer);

                export default () => {
                  &lt;Provider store={store}&gt;
                    &ltApp /&gt;
                  &lt;/Provider&gt;
                }
            </code></pre>
          </section>
          <section>
            <h4>Classic</h4>
            Uses <code>connect</code> from <code>react-redux</code>
            <pre><code data-trim data-noescape class="javascript">
              const UnconnectedComponent = ({ value, onValueChange }) => {
                const onChange = (e) => {
                  onValueChange(e.target.value);
                }
                return (&lt;textarea value={value} onChange={onChange} /&gt;)
              }

              const mapStateToProps = (state /*, ownProps */) => ({
                value: selectors.getValue(state)
              })

              export default connect(
                mapStateToProps, {
                    onChange: actions.updateValue
                })(UnconnectedComponent)
            </code></pre>
          </section>
          <section>
            <h4>Hooks version</h4>
            <pre><code data-trim data-noescape class="javascript">
            import { useDispatch, useSelector } from 'react-redux';

            export default () => {
              const dispatch = useDispatch();
              const value = useSelector(selectors.getValue)
              const onChange = (e) => {
                dispatch(actions.updateValue(e.target.value))
              }
              return (&lt;textarea value={value} onChange={onChange} /&gt;)
            }
            </code></pre>
            <p class="fragment">Less code, but more difficult to test</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Advanced behavior</h2>
            <ul>
              <li>Middlewares can customize redux behavior</li>
              <li>Logging middleware produces advanced logging</li>
              <li>Thunk middleware handles async behavior</li>
              <li>Support for RxJS, Sagas, and more</li>
            </ul>
          </section>
          <section>
            <h2>Thunk middleware</h2>
            Allows creatins async <em>Action Creators</em>
            <pre><code data-trim data-noescape class="javascript">
              const loadFineTuningGains =
                (patientId) => async (dispatch /* optional: , getState */) =>
              {
                dispatch(setLoadingState());
                try {
                  const fineTuning = fineTuningService.getFineTuningGains(patientId);
                  dispatch(setFineTuningLoaded(fineTuning));
                } catch (e) {
                  dispatch(setFineTuningLoadFailed(e));
                }
              }

              // "dispatch" returns a Promise for thunk action creators
              await store.dispatch(loadFineTuningGains("PATIENT_ID"));
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <h1>Writing Tests</h1>
            Avoid official test guidelines
          </section>
          <section>
            <h2>Test Store as a Whole</h2>
            <ul>
              <li>Create a store in test code</li>
              <li>Dispatch Actions using Action Creators</li>
              <li>Veridy state using Selectors</li>
              <li>Tests now facilitate refactoring</li>
            </ul>
          </section>
          <section>
            <h2>Example</h2>
            <pre><code data-trim data-noescape class="javascript">
                describe("Some piece of data", () => {
                  it("Has initial state 'foo'", () => {
                    const store = createStore();
                    const actual = selectors.getData(store.getState())
                    actual.should.equal('foo')
                  })
                  it("Has state 'bar' after update", () => {
                    const store = createStore();
                    store.dispatch(actions.doBar());
                    const actual = selectors.getData(store.getState())
                    actual.should.equal('bar')
                  })
                })
            </code></pre>
          </section>
          <section>
            <h2>Helpers in FixXP</h2>
            <pre><code data-trim data-noescape class="javascript">
              describe("This thing", useStore({ dispatch, select }, () => {
                  it("Has initial state 'foo'", () => {
                    const actual = select(selectors.getData)
                    actual.should.equal('foo')
                  })
                  it("Has state 'bar' after update", () => {
                    dispatch(actions.doBar());
                    const actual = select(selectors.getData)
                    actual.should.equal('bar')
                  })
              }));
            </code></pre>
          </section>
          <section>
            <h2>Testing Async Code</h2>
            <pre><code data-trim data-noescape class="javascript">
                  beforeEach(() => { stub = sinon.stub(api, 'doSomething') });

                  it("While loading", () => {
                    stub.returns(new Promise(r => {}));
                    dispatch(actions.doSomethingAsync());
                    const actual = select(selectors.getStatus)
                    actual.should.equal('LOADING')
                  })
                  it("When loaded", async () => {
                    stub.resolve(createValidResponse());
                    await dispatch(actions.doSomethingAsync());
                    const actual = select(selectors.getStatus)
                    actual.should.equal('LOADED')
                  })
            </code></pre>
          </section>
          <section>
            <h2>Testing Race Conditions</h2>
            <pre><code data-trim data-noescape class="javascript">
              it("Handles responses out of order", () => {
                const clock = sinon.useFakeTimers();
                const stub = sinon.stub(api, 'doSomething')
                stub.withArgs("PATIENT_1")
                    .returns(new Promise(r => { setTimeout(r, 2) }));
                stub.withArgs("PATIENT_2")
                    .returns(new Promise(r => { setTimeout(r, 1) }));
                await Promise.all([
                  dispatch(actions.loadPatient("PATIENT_1")),
                  dispatch(actions.loadPatient("PATIENT_2")),
                  clock.tick(2)
                ])
                // Patient who was requested last will be received first
                select(selectors.getPatientId).should.equal("PATIENT_2")
              })
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>Tips</h2>
            <ul>
              <li>Components rerender when selected data change</li>
              <li>Selectors <em>should</em> return <em>equal</em> for same input</li>
              <li>The <code>useRedux</code> helper's <code>select</code> function verifies this</li>
              <li><code>reselect</code> library helps create memoized selectors</li>
            </ul>
          </section>
          <section>
            <h2>Using Reselect</h2>
            <pre><code data-trim data-noescape class="javascript">
              // When called twice, this will not return equal results for same
              // input, forcing unnecessary rerenders.
              const badVersion = (state: RootState) => {
                const x = state.substate.data1,
                const y = state.substate.data2,
                const z = state.substate.data3,
                return { x, y, z }
              )
              // Good version - createSelector creates a memoized version
              const complexSelectorThatCalculatesState = createSelector(
                state => state.substate.data1,
                state => state.substate.data2,
                state => state.substate.data3,
                (data1, data2, data3) => ({ x: data1, y: data2, z: data3 })
              )
            </code></pre>
          </section>
        </section>
        <section>
          <h2>Links</h2>
          <ul>
            <li><a href="https://reactjs.org/docs/forms.html#controlled-components">Controlled Components</a></li>
            <li>Lifting state up:
              <a href="https://reactjs.org/docs/lifting-state-up.html">
                https://reactjs.org/docs/lifting-state-up.html</a></li>
            <li>Redux toolkit:
              <a href="https://redux-toolkit.js.org/"> https://redux-toolkit.js.org/ </a></li>
            <li>Dan Abramovs courses (pre react hooks API &amp; no typescript):
              <ul><li><a href="https://egghead.io/courses/getting-started-with-redux">
                    https://egghead.io/courses/getting-started-with-redux</a></li>
                <li><a href="https://egghead.io/courses/building-react-applications-with-idiomatic-redux">
                    https://egghead.io/courses/building-react-applications-with-idiomatic-redux</a></li>
              </ul>
            </li>
            <li>
              Dan Abramov - Live React: Hot Reloading with Time Travel at react-europe 2015
              <a href="https://www.youtube.com/watch?v=xsSnOQynTHs">
                https://www.youtube.com/watch?v=xsSnOQynTHs</a>
            </li>
        </section>
      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        history: true,
        hash: true,
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/highlight/highlight.js', async: true },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/mermaid/mermaid.js' }
        ]
      });
    </script>
  </body>
</html>
